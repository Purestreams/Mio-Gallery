<!DOCTYPE html>
<html lang="en" data-rw-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manage Gallery</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/@rewind-ui/core/dist/rewind-ui.min.css"
  />

  <style>
    :root {
      --surface: #ffffff;
      --border: #e5e7eb;
      --muted: #6b7280;
      --muted-strong: #374151;
      --shadow: 0 10px 30px rgba(15, 23, 42, 0.12);
      --bg: #f8fafc;
      --text: #1f2937;
      --accent: var(--rw-color-primary-600, #2563eb);
    }
    [data-theme="dark"] {
      --surface: #0f172a;
      --border: #1f2937;
      --muted: #cbd5e1;
      --muted-strong: #e2e8f0;
      --shadow: 0 16px 44px rgba(0, 0, 0, 0.35);
      --bg: #0b1220;
      --text: #e2e8f0;
      --accent: var(--rw-color-primary-400, #60a5fa);
    }
    body {
      margin: 0;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 20px 64px;
    }
    header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
    }
    .title {
      font-size: 28px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    .subtitle {
      color: var(--muted);
      margin-top: 4px;
      font-size: 15px;
    }
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 18px;
      box-shadow: var(--shadow);
    }

    footer {
      margin-top: 18px;
      text-align: center;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }
    footer a {
      color: inherit;
      text-decoration: none;
      font-weight: 600;
    }
    footer a:hover {
      color: var(--muted-strong);
      text-decoration: underline;
    }
    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      margin-bottom: 14px;
    }
    .left {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    input[type="file"] {
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
    }
    .btn {
      height: 40px;
      padding: 0 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--muted-strong);
      cursor: pointer;
      font-weight: 700;
      transition: all 0.2s ease;
    }
    .btn:hover {
      border-color: var(--muted);
      transform: translateY(-1px);
    }
    .btn.primary {
      background: var(--rw-color-primary-600, #2563eb);
      color: #fff;
      border-color: var(--rw-color-primary-600, #2563eb);
    }
    .btn.danger {
      background: #fff;
      color: #b91c1c;
      border-color: #fecaca;
    }
    .btn.danger:hover {
      border-color: #fca5a5;
    }
    .status {
      color: var(--muted);
      font-size: 14px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 16px;
    }
    .item {
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      background: #fff;
    }
    .thumb {
      position: relative;
      aspect-ratio: 4 / 3;
      background: #f1f5f9;
      overflow: hidden;
    }
    .thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .meta {
      padding: 10px 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .label {
      font-size: 13px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .actions {
      display: flex;
      gap: 8px;
    }
    .small {
      height: 34px;
      padding: 0 10px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 13px;
    }

    .desc {
      width: 100%;
      min-height: 78px;
      resize: vertical;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--surface);
      color: var(--muted-strong);
      font-family: inherit;
      font-size: 13px;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div class="page">
    <header>
      <div>
        <div class="title">Manage Gallery</div>
        <div class="subtitle">Upload, pin, and delete images.</div>
      </div>
      <div class="left">
        <button class="btn" id="themeToggle" aria-label="Toggle theme">ðŸŒ™ Dark</button>
        <button class="btn" id="backBtn">Back</button>
        <div class="status" id="status"></div>
      </div>
    </header>

    <div class="card">
      <div class="toolbar">
        <div class="left">
          <input id="fileInput" type="file" multiple accept="image/*" />
          <button class="btn primary" id="uploadBtn">Upload</button>
          <button class="btn" id="refreshBtn">Refresh</button>
        </div>
      </div>

      <div class="grid" id="grid"></div>
    </div>

    <footer>
      &copy; <span id="footerYear"></span> Mio-Gallery &middot;
      <a href="https://github.com/Purestreams/Mio-Gallery" target="_blank" rel="noopener noreferrer">GitHub</a>
    </footer>
  </div>

  <script>
    const API_BASE = window.location.origin;
    const THEME_KEY = "mio-theme";
    const themeToggleBtn = document.getElementById("themeToggle");
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)");

    function applyTheme(theme) {
      const t = theme === "dark" ? "dark" : "light";
      document.documentElement.dataset.theme = t;
      localStorage.setItem(THEME_KEY, t);
      if (themeToggleBtn) {
        themeToggleBtn.textContent = t === "dark" ? "â˜€ï¸ Light" : "ðŸŒ™ Dark";
        themeToggleBtn.setAttribute("aria-label", t === "dark" ? "Switch to light mode" : "Switch to dark mode");
      }
    }

    function initTheme() {
      const stored = localStorage.getItem(THEME_KEY);
      const initial = stored || (prefersDark.matches ? "dark" : "light");
      applyTheme(initial);
      prefersDark.addEventListener("change", (e) => {
        if (!localStorage.getItem(THEME_KEY)) applyTheme(e.matches ? "dark" : "light");
      });
    }

    if (themeToggleBtn) {
      themeToggleBtn.onclick = () => {
        const next = document.documentElement.dataset.theme === "dark" ? "light" : "dark";
        applyTheme(next);
      };
    }

    initTheme();

    const statusEl = document.getElementById("status");
    const gridEl = document.getElementById("grid");
    const fileInput = document.getElementById("fileInput");

    function setStatus(text) {
      statusEl.textContent = text || "";
    }

    function absUrl(path) {
      if (!path) return null;
      return new URL(path, API_BASE).toString();
    }

    function pickPreferredSrc(photo) {
      const avif = absUrl(photo.avif);
      const webp = absUrl(photo.webp);
      return { src: avif || webp, fallback: webp };
    }

    function pickThumbSrc(photo) {
      return absUrl(photo.thumb);
    }

    function applyAvifFallback(imgEl, fallbackUrl) {
      if (!fallbackUrl) return;
      const handler = () => {
        imgEl.removeEventListener("error", handler);
        if (imgEl.src !== fallbackUrl) imgEl.src = fallbackUrl;
      };
      imgEl.addEventListener("error", handler);
    }

    async function apiJson(path, options) {
      const resp = await fetch(new URL(path, API_BASE), options);
      if (!resp.ok) {
        const text = await resp.text().catch(() => "");
        throw new Error(`HTTP ${resp.status} ${text}`);
      }
      if (resp.status === 204) return null;
      return await resp.json();
    }

    async function loadList() {
      setStatus("Loadingâ€¦");
      gridEl.innerHTML = "";
      try {
        const data = await apiJson("/api/images");
        const images = Array.isArray(data.images) ? data.images : [];
        render(images);
        setStatus(`${images.length} images`);
      } catch (e) {
        setStatus("Failed to load. Is the API running?");
      }
    }

    function render(images) {
      gridEl.innerHTML = "";
      if (!images.length) {
        gridEl.innerHTML = "No images.";
        return;
      }

      for (const photo of images) {
        const div = document.createElement("div");
        div.className = "item";

        const { src: fullSrc, fallback } = pickPreferredSrc(photo);
        const thumbSrc = pickThumbSrc(photo) || fullSrc;
        const caption = photo.date || photo.id || "";
        const description = (photo.description || "").toString();

        div.innerHTML = `
          <div class="thumb"><img alt="${caption}" loading="lazy" /></div>
          <div class="meta">
            <div class="row">
              <div class="label">${caption}${photo.pinned ? " (pinned)" : ""}</div>
            </div>
            <div class="row">
              <textarea class="desc" placeholder="Descriptionâ€¦">${description.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")}</textarea>
            </div>
            <div class="row">
              <div class="actions">
                <button class="btn small" data-action="pin">${photo.pinned ? "Unpin" : "Pin"}</button>
                <button class="btn small" data-action="save">Save</button>
                <button class="btn small danger" data-action="delete">Delete</button>
              </div>
            </div>
          </div>
        `;

          const img = div.querySelector("img");
          img.src = thumbSrc || "";
        applyAvifFallback(img, fallback);

        div.querySelector('[data-action="pin"]').onclick = async () => {
          try {
            setStatus("Updatingâ€¦");
            await apiJson(`/api/images/${encodeURIComponent(photo.id)}/pin`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ pinned: !photo.pinned }),
            });
            await loadList();
          } catch (e) {
            setStatus("Pin failed");
          }
        };

        div.querySelector('[data-action="save"]').onclick = async () => {
          const textarea = div.querySelector("textarea.desc");
          const newDesc = (textarea?.value || "").toString();
          try {
            setStatus("Savingâ€¦");
            await apiJson(`/api/images/${encodeURIComponent(photo.id)}/description`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ description: newDesc }),
            });
            await loadList();
            setStatus("Saved");
          } catch (e) {
            setStatus("Save failed");
          }
        };

        div.querySelector('[data-action="delete"]').onclick = async () => {
          if (!confirm("Delete this image?")) return;
          try {
            setStatus("Deletingâ€¦");
            await apiJson(`/api/images/${encodeURIComponent(photo.id)}`, { method: "DELETE" });
            await loadList();
          } catch (e) {
            setStatus("Delete failed");
          }
        };

        gridEl.appendChild(div);
      }
    }

    document.getElementById("refreshBtn").onclick = loadList;
    document.getElementById("backBtn").onclick = () => {
      window.location.href = "/";
    };

    document.getElementById("uploadBtn").onclick = async () => {
      const files = Array.from(fileInput.files || []);
      if (!files.length) {
        setStatus("Select files first");
        return;
      }

      const uploadBtn = document.getElementById("uploadBtn");
      const refreshBtn = document.getElementById("refreshBtn");
      const setUploadingUi = (uploading) => {
        if (uploadBtn) uploadBtn.disabled = uploading;
        if (refreshBtn) refreshBtn.disabled = uploading;
        if (fileInput) fileInput.disabled = uploading;
      };

      // Browser JS doesn't create OS threads, but we can upload multiple files concurrently
      // by issuing multiple HTTP requests in parallel (concurrency-limited).
      const DEFAULT_CONCURRENCY = Math.min(4, Math.max(2, Number(navigator.hardwareConcurrency || 4) >= 8 ? 4 : 3));
      const concurrency = DEFAULT_CONCURRENCY;

      // Live speed tracking helpers
      const totalBytes = files.reduce((sum, f) => sum + (f?.size || 0), 0);
      let bytesUploaded = 0; // includes in-flight progress
      const fileProgress = new Map(); // file -> last loaded bytes
      const startTs = performance.now();

      function formatBytes(bytes) {
        const b = Number(bytes || 0);
        if (b < 1024) return `${b} B`;
        if (b < 1024 * 1024) return `${(b / 1024).toFixed(1)} KB`;
        return `${(b / (1024 * 1024)).toFixed(2)} MB`;
      }

      function formatSpeed(bps) {
        const s = Number(bps || 0);
        if (s < 1024) return `${s.toFixed(0)} B/s`;
        if (s < 1024 * 1024) return `${(s / 1024).toFixed(1)} KB/s`;
        return `${(s / (1024 * 1024)).toFixed(2)} MB/s`;
      }

      function onProgress(file, loaded, total) {
        const prev = fileProgress.get(file) || 0;
        // Only add positive deltas
        const delta = Math.max(0, Number(loaded || 0) - Number(prev || 0));
        if (delta > 0) {
          bytesUploaded += delta;
          fileProgress.set(file, loaded);
          updateProgress();
        }
      }

      async function uploadOneFile(file, attempt = 1) {
        const startedAt = performance.now();
        const form = new FormData();
        form.append("image", file);

        // Use XMLHttpRequest to get upload progress events
        function sendOnce() {
          return new Promise((resolve) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", new URL("/api/upload", API_BASE).toString(), true);

            xhr.upload.onprogress = (e) => {
              if (e && e.lengthComputable) {
                onProgress(file, e.loaded, e.total);
              }
            };

            xhr.onreadystatechange = () => {
              if (xhr.readyState === 4) {
                const ok = xhr.status >= 200 && xhr.status < 300;
                resolve({ ok, status: xhr.status, text: xhr.responseText });
              }
            };

            xhr.onerror = () => {
              resolve({ ok: false, status: 0, text: "Network error" });
            };

            xhr.send(form);
          });
        }

        const res = await sendOnce();
        if (!res.ok) {
          const transient = res.status === 408 || res.status === 429 || (res.status >= 500 && res.status <= 599) || res.status === 0;
          if (attempt < 2 && transient) {
            await new Promise((r) => setTimeout(r, 500));
            return uploadOneFile(file, attempt + 1);
          }
        }

        // Ensure final progress counts full file on success
        if (res.ok) {
          const last = fileProgress.get(file) || 0;
          if (last < (file?.size || 0)) {
            bytesUploaded += (file?.size || 0) - last;
            fileProgress.set(file, file?.size || 0);
          }
          const elapsedSec = Math.max(0.001, (performance.now() - startedAt) / 1000);
          res.speedBps = (file?.size || 0) / elapsedSec;
        }

        return res;
      }

      async function runPool(items, workerFn, limit) {
        const results = new Array(items.length);
        let nextIndex = 0;
        const workers = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
          while (true) {
            const i = nextIndex++;
            if (i >= items.length) return;
            results[i] = await workerFn(items[i], i);
          }
        });
        await Promise.all(workers);
        return results;
      }

      let completed = 0;
      let succeeded = 0;
      let failed = 0;
      let avgSpeedAcc = 0; // sum of speeds for succeeded files
      let avgSpeedCount = 0; // number of succeeded files

      const updateProgress = () => {
        const elapsed = Math.max(0.001, (performance.now() - startTs) / 1000);
        const currentBps = bytesUploaded / elapsed;
        const avgBps = avgSpeedCount > 0 ? avgSpeedAcc / avgSpeedCount : 0;
        const bytesText = `${formatBytes(bytesUploaded)} / ${formatBytes(totalBytes)}`;
        const speedText = `speed ${formatSpeed(currentBps)} (avg ${formatSpeed(avgBps)})`;
        setStatus(`Uploadingâ€¦ ${completed}/${files.length} (ok ${succeeded}, failed ${failed}) â€¢ ${bytesText} â€¢ ${speedText}`);
      };

      try {
        setUploadingUi(true);
        updateProgress();

        const results = await runPool(
          files,
          async (file) => {
            const r = await uploadOneFile(file);
            completed += 1;
            if (r.ok) succeeded += 1;
            else {
              failed += 1;
              console.warn("Upload failed:", file?.name, r);
            }
            if (r.ok && r.speedBps) {
              avgSpeedAcc += r.speedBps;
              avgSpeedCount += 1;
            }
            updateProgress();
            return r;
          },
          concurrency
        );

        fileInput.value = "";
        await loadList();

        if (failed === 0) {
          setStatus(`Upload complete (${succeeded}/${files.length})`);
        } else if (succeeded === 0) {
          setStatus(`Upload failed (${failed}/${files.length})`);
        } else {
          setStatus(`Upload partial: ok ${succeeded}, failed ${failed}`);
        }

        return results;
      } catch (e) {
        console.error(e);
        setStatus("Upload failed");
      } finally {
        setUploadingUi(false);
      }
    };

    document.getElementById("footerYear").textContent = new Date().getFullYear();

    loadList();
  </script>
</body>
</html>
